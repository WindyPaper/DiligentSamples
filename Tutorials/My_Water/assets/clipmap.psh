#include "brdf.fxh"
#include "lighting_structure.fxh"

Texture2D    g_DiffTexture;
SamplerState g_DiffTexture_sampler; // By convention, texture samplers must use the '_sampler' suffix

Texture2D    g_displacement_tex;
SamplerState g_displacement_tex_sampler; // By convention, texture samplers must use the '_sampler' suffix

cbuffer cbLightStructure
{
    XLightStructure g_LightStructure;
};

struct PSInput 
{ 
    float4 Pos : SV_POSITION;
    float2 UV  : TEX_COORD;
    float3 Normal : TEX_COORD1;
    float3 WorldPos : TEX_COORD2;
    float3 CamPos : TEX_COORD3;
    float2 L_RepeatScale : TEX_COORD4;
};

struct PSOutput
{ 
    float4 Color : SV_TARGET; 
};

float3 CalWorldNormal(float2 TexCoord, float PixelSize, float TexelSize)
{
    float3 center = g_displacement_tex.Sample(g_displacement_tex_sampler, TexCoord).xyz;
    float3 right = float3(TexelSize, 0.0f, 0.0f) + g_displacement_tex.Sample(g_displacement_tex_sampler, TexCoord + float2(PixelSize, 0.0f)).xyz - center;
    float3 left = float3(-TexelSize, 0.0f, 0.0f) + g_displacement_tex.Sample(g_displacement_tex_sampler, TexCoord + float2(-PixelSize, 0.0f)).xyz - center;
    float3 top = float3(0.0f, 0.0f, -TexelSize) + g_displacement_tex.Sample(g_displacement_tex_sampler, TexCoord + float2(0.0f, -PixelSize)).xyz - center;
    float3 bottom = float3(0.0f, 0.0f, TexelSize) + g_displacement_tex.Sample(g_displacement_tex_sampler, TexCoord + float2(0.0f, PixelSize)).xyz - center;

    float3 TopRight = cross(right, top);
    float3 TopLeft = cross(top, left);
    float3 BottomLeft = cross(left, bottom);
    float3 BottomRight = cross(bottom, right);

    return normalize(TopRight + TopLeft + BottomLeft + BottomRight);
}

float3 PhongLighting(float3 LightDir, float3 ViewDir, float3 Normal)
{
    float3 HalfVec = normalize(LightDir + ViewDir);

    float ndh = saturate(dot(Normal, HalfVec));
    return pow(ndh, 100);
}

// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be indentical.
void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
    float N = 256.0f;    
    float L = PSIn.L_RepeatScale.x;
    float WaterTextureScale = PSIn.L_RepeatScale.y;
    float PixelSize = 1.0f / N * WaterTextureScale;
    float TexelSize = L / N * WaterTextureScale;
    float3 WorldNormal = CalWorldNormal(PSIn.UV, PixelSize, TexelSize);

    float3 WorldPos = PSIn.WorldPos;
    float3 ViewDir = normalize(PSIn.CamPos - WorldPos);    

	float3 LightDir = normalize(g_LightStructure.Direction.xyz);
    float DLIntensity = g_LightStructure.Direction.w;
	// float ndl = saturate(dot(LightDir, WorldNormal));
	// float3 DirLightIrradiance = ndl * float3(1, 1, 1);
	//float3 Ambient = float3(0.1, 0.1, 0.1);

    //float3 PhongColor = PhongLighting(LightDir, ViewDir, WorldNormal) * DLIntensity;

    float3 UskyColor = float3(3.2, 9.6, 12.8)/100.0;

    float3 UOceanColor = float3(0.04, 0.16, 0.47);

    BxDFContext BrdfContext;
    InitBrdf(BrdfContext, WorldNormal, ViewDir, LightDir);
    BrdfContext.NoV = saturate( abs( BrdfContext.NoV ) + 1e-5 );
    float3 WaterDiffuse = Diffuse_Lambert(UOceanColor) * DLIntensity * saturate(BrdfContext.NoL);
    //float3 WaterDiffuse = DLIntensity * saturate(BrdfContext.NoL);
    float3 WaterSpecular = SpecularGGX(0.4f, UskyColor, BrdfContext, saturate(BrdfContext.NoL));
    //float Fresnel = 0.02 + 0.98 * pow(1.0 - dot(WorldNormal, ViewDir), 5.0);
    //float3 Sky = Fresnel * UskyColor;
    //float diffuse = saturate(dot(WorldNormal, LightDir));
    //float3 WaterColor = (1.0 - Fresnel) * UOceanColor * UskyColor * diffuse;

    //float3 center = g_displacement_tex.Sample(g_displacement_tex_sampler, PSIn.UV).xyz * 0;

    PSOut.Color.rgb = WaterDiffuse + WaterSpecular; //g_DiffTexture.Sample(g_DiffTexture_sampler, PSIn.UV); //float4(1.0, 1.0, 1.0, 1.0); 
    PSOut.Color.a = 1.0;

    //float morphv = PSIn.Morph.x;
    //PSOut.Color = float4(morphv, morphv, morphv, 1.0f); //float4(1.0, 1.0, 1.0, 1.0); 
}
