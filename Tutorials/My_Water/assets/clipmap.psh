#include "assets/brdf.fxh"
#include "assets/lighting_structure.fxh"

cbuffer Constants
{
    float4x4 g_ViewProj;
    float4 g_MorphK;
    float4 g_CameraPos;

    float2 g_L_FFTScale; //x:L  y:Scale
    float g_BaseNormalIntensity;
    float g_FFTN;

    float LengthScale0;
    float LengthScale1;
    float LengthScale2;
    float LOD_scale;
};

cbuffer OceanMaterialParams
{
    float4 OceanColor;
    float4 SSSColor;

    float SSSStrength;
    float SSSScale;
    float SSSBase;
    float LodScale;

    float MaxGloss;
    float Roughness;
    float RoughnessScale;
    float ContactFoam;

    float4 FoamColor;

    float FoamBiasLod0;
    float FoamBiasLod1;
    float FoamBiasLod2;
    float FoamScale;    
};

Texture2D g_derivatives_texL0;
SamplerState g_derivatives_texL0_sampler;

Texture2D g_derivatives_texL1;
SamplerState g_derivatives_texL1_sampler;

Texture2D g_derivatives_texL2;
SamplerState g_derivatives_texL2_sampler;

Texture2D g_turbulence_texL0;
SamplerState g_turbulence_texL0_sampler;

Texture2D g_turbulence_texL1;
SamplerState g_turbulence_texL1_sampler;

Texture2D g_turbulence_texL2;
SamplerState g_turbulence_texL2_sampler;

TextureCube g_IrradianceCube;
SamplerState g_IrradianceCube_sampler;

TextureCube g_IBLSpecCube;
SamplerState g_IBLSpecCube_sampler;

cbuffer cbLightStructure
{
    XLightStructure g_LightStructure;
};

struct PSInput 
{ 
    float4 Pos : SV_POSITION;
    float2 UV  : TEX_COORD;
    float3 WorldPos : TEX_COORD1;
    float3 CamPos : TEX_COORD2;
    float4 LodScales : TEX_COORD3;
};

struct PSOutput
{ 
    float4 Color : SV_TARGET; 
};

float3 PhongLighting(float3 LightDir, float3 ViewDir, float3 Normal)
{
    float3 HalfVec = normalize(LightDir + ViewDir);

    float ndh = saturate(dot(Normal, HalfVec));
    return pow(ndh, 100);
}

// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be indentical.
void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{    

    float3 WorldPos = PSIn.WorldPos;
    float3 ViewDir = normalize(PSIn.CamPos - WorldPos);    

    float4 derivatives = g_derivatives_texL0.Sample(g_derivatives_texL0_sampler, PSIn.UV / LengthScale0);
    //#if defined(MID) || defined(CLOSE)
    derivatives += g_derivatives_texL1.Sample(g_derivatives_texL1_sampler, PSIn.UV / LengthScale1) * PSIn.LodScales.y;
    //#endif

    //#if defined(CLOSE)
    derivatives += g_derivatives_texL2.Sample(g_derivatives_texL2_sampler, PSIn.UV / LengthScale2) * PSIn.LodScales.z;
    //#endif

    float2 slope = float2(derivatives.x / (1 + derivatives.z),
        derivatives.y / (1 + derivatives.w));
    float3 WorldNormal = normalize(float3(-slope.x, 1, -slope.y));

    //Foam
    float jacobian = g_turbulence_texL0.Sample(g_turbulence_texL0_sampler, PSIn.UV / LengthScale0).x
                + g_turbulence_texL1.Sample(g_turbulence_texL1_sampler, PSIn.UV / LengthScale1).x
                + g_turbulence_texL2.Sample(g_turbulence_texL2_sampler, PSIn.UV / LengthScale2).x;
    //jacobian = min(1, max(0, (-jacobian + 2.52f) * 2.4f));
    jacobian = min(1, max(0, (-jacobian + FoamBiasLod2) * FoamScale));

    float3 Albedo = lerp(0.1, FoamColor * 3.0f, jacobian);
    float _Roughness = 0.3f;
    float _RoughnessScale = 0.004f;
    float _MaxGloss = 0.9f;
    float distanceGloss = lerp(1 - _Roughness, _MaxGloss, 1 / (1 + length(PSIn.CamPos - WorldPos) * _RoughnessScale));
    float FinalRoughness = (1.0 - lerp(distanceGloss, 0.0, jacobian));
    

	float3 LightDir = normalize(g_LightStructure.Direction.xyz);
    float DLIntensity = g_LightStructure.Direction.w;	

    float Metallic = 0.0f;
    SurfaceReflectanceInfo SrfInfo = PBR_GetSurfaceReflectance(Albedo, FinalRoughness, Metallic);
    float3 DirectLighting = PBR_ApplyDirectionalLight(LightDir, DLIntensity, SrfInfo, WorldNormal, ViewDir);


    //float3 IndirectedDiff = g_IrradianceCube.Sample(g_IrradianceCube_sampler, WorldNormal).rgb;

    //PSOut.Color.rgb = DirectLighting;// + IndirectedDiff * 10000000.0;// + lerp(LightingColor, float3(1, 1, 1), FoamIntensity) * 0.0001f;    
    //PSOut.Color.rgb = DirectLighting * 1.000001f + IndirectedDiff * 1.0f;// + lerp(LightingColor, float3(1, 1, 1), FoamIntensity) * 0.0001f;    

    //IBL Lighting
    PBR_IBL_Contribution IBLLighting = PBR_GetIBLContribution(SrfInfo, WorldNormal, ViewDir, 8, \
        g_IrradianceCube, g_IrradianceCube_sampler, g_IBLSpecCube, g_IBLSpecCube_sampler);

    float3 IndirectedLighting = IBLLighting.f3Diffuse + IBLLighting.f3Specular;
    PSOut.Color.rgb = DirectLighting * 1.000001f + IndirectedLighting * 1.0f;// + lerp(LightingColor, float3(1, 1, 1), FoamIntensity) * 0.0001f;    

    //SSS    
    float3 H = normalize(-WorldNormal + LightDir);
    float ViewDotH = Pow5(saturate(dot(ViewDir, -H))) * 30 * SSSStrength;
    float3 color = lerp(OceanColor.rgb, saturate(OceanColor.rgb + SSSColor.rgb * ViewDotH * PSIn.LodScales.w), PSIn.LodScales.z);

    float fresnel = dot(WorldNormal, ViewDir);
    fresnel = saturate(1 - fresnel);
    fresnel = Pow5(fresnel);

    float3 OutOceanSSS = lerp(color * (1 - fresnel), 0, jacobian);
    //PSOut.Color.rgb *= 0.00000000001f;
    PSOut.Color.rgb += OutOceanSSS;//PSIn.LodScales.w;//ViewDotH;


    PSOut.Color.a = 1.0;

    //float morphv = PSIn.Morph.x;
    //PSOut.Color = float4(morphv, morphv, morphv, 1.0f); //float4(1.0, 1.0, 1.0, 1.0); 
}
